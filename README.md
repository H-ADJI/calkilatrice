# Math Expression Evaluator

Small CLI to parse and evaluate basic mathematical expression using a tree-walk strategy.
This interpreter support binary operations on 64 bits floating point numbers and some basic math functions :

- Trigonometric functions : cos(θ) - acos(b) - sin(θ) - asin(b) - tan(θ) - atan(b)
- square root function : sqrt(a)
- binary operations :
  - addition : a + b
  - substraction : a - b
  - exponentiation : a ^ b
  - multiplication : a * b
  - division : a / b

## Dependencies

The project is written in Go, the compiler version used is `1.21.5` on a debian machine

### Why Go ?

Started learning it a month ago and took this project as an exercise to get more familiar with the language syntax and concepts.

## Running the program

- if you have go installed, cd to to the project directory and run : `go run main.go --help` to list all possible options for this CLI
- or you can download the binary on the release section of this repo.
- evaluation an expression : `go run main.go --expr "<your very complicated math expression>"`
  - Example : `go run main.go --expr "1 + 2*sin(3.14/2) - tan(3.14/4)"`, this should output 2 as a result.
- There are other options that can be activated like using Degree instead of the default Radians for trigonometric operations, logging out the AST or the Tokens. You can find how to use them using the --help option.

```bash
Usage of ./mathEval:
  -S	Shows the list of mathematical operations supported by this calculator
  -expr string
    	Mathematical expression to evaluate. Example : 1/2 - (4 - cos(10^2)) (default "2*sin(30)")
  -include-ast
    	Add looging the evaluated ast to the output
  -include-tokens
    	Add looging the parsed tokens to the output
  -use-degrees
    	Enable Trigonometric functions evaluation using Degrees as a unit instead of Radians
```

## Implementation details

### Pipeline

To read an arithmetic operation and compute its result, the math expression go through the steps described bellow :
![Pipeline image](/assets/InterpreterPipeline.png "Pipeline")

### Step 1 : Tokenizing

This step is also called lexical analysis, where the stream of characters of our language is converted into a list of tokens (a token is a group of characters that have a meaning in our grammar).

For the tokenizer we used a list of regular expressions that will help us match the tokens of our language at the start of the expression string, each time a token found, we append it to our resulting tokens list and we skip the matched characters on the following iterations.

This is a simple but inefficient way to generate the tokens since our regex will have to scan the same characters multiple times. For faster tokenizers **real world** implementation uses Finite Automatas (DFA / NFA).

When evaluation an expression we can use the `--include-tokens` option to print the tokens list generated by the lexer.

### Step 2 : Parsing

To describe the grammar / syntax of our language we will be using the following Backus-Naur form (BNF) notation:

Our entry point is the math expression defined as EXPRESSION, then each production rule recursively define other production rule until reaching the Terminals.

The grammar is defined in a way to account for binary operations precedence, such as the closer a production is to the terminals the more precedence it has.

```BNF
EXPRESSION
    : ADDITION
    ;

ADDITION
    : ADDITION ('+' | '-') funcCALL
    | funcCALL
    ;

funcCALL
    : MULTIPLICATION
    | mathFunc'(' EXPRESSION ')'
    ;

MULTIPLICATION
    : MULTIPLICATION ('*' | '/') EXPONENTIATION
    | EXPONENTIATION
    ;

EXPONENTIATION
    : EXPONENTIATION '^' TERMINALS
    | TERMINALS
    ;

TERMINALS
    : number
    | '(' EXPRESSION ')'
    | mathFunc
    ;
```

The result of the parsing process is a tree structure called AST. When evaluation an expression we can use the `--include-ast` option to print the tree generated by the parser.

### Step 3 : Evaluation
The last step in the interpretation pipeline is to evaluate the resulting AST, this is done using a post order traversal of the tree nodes since the operation with most precedence are in the leafs of the tree.
<p align="center"><img src="/assets/traversal.png" /></p>

### Handling invalid input

The interpreter reports invalid input when we feed it with some unsupported expressions or tokens either during the lexing phase (tokens that are not included in the grammar), or during the parsing phase for expression with invalid syntax.

The golang implementation of the math function will return a NaN of inf output if called outside of their definition interval. Example asin(5)  will output NaN since it's defined on the [-1,1] interval.

### Error reporting

While it's not a complete / accurate feature, the interpreter try to give directions about the token / the character position causing the invalid expression / error.

Number precision and possible overflow issues where not accounted for in this toy project :(.